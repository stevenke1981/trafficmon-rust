name: Build OpenWrt Package

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-x86_64:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    name: Build for x86_64

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build using OpenWrt SDK Docker
      run: |
        # 使用 Docker 運行 OpenWrt SDK 進行編譯
        docker run --rm -v "$(pwd):/build" -w /build \
          --user root openwrt/sdk:x86_64-24.10.0 \
          /bin/bash -c "
            set -e  # 遇到錯誤立即退出
            set -x  # 顯示執行的命令
            
            echo '=== 當前目錄和檔案 ==='
            pwd
            ls -la
            
            # 更改工作目錄到可寫入的位置進行 Rust 編譯
            cd /tmp
            
            # 複製原始碼
            cp -r /build/. /tmp/src
            cd /tmp/src
            
            echo '=== 安裝 Rust ==='
            # 安裝 Rust（使用非互動模式）
            export CARGO_HOME=/tmp/cargo
            export RUSTUP_HOME=/tmp/rustup
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable --no-modify-path
            export PATH=\$PATH:/tmp/cargo/bin
            
            echo '=== 添加 musl 目標 ==='
            # 添加 musl 目標
            rustup target add x86_64-unknown-linux-musl
            
            echo '=== 編譯 Rust 二進位檔案 ==='
            # 編譯 Rust 二進位檔案
            cargo build --release --target x86_64-unknown-linux-musl --jobs \$(nproc)
            
            echo '=== 檢查編譯結果 ==='
            ls -la target/x86_64-unknown-linux-musl/release/
            
            # 回到 OpenWrt SDK 目錄
            cd /build
            
            echo '=== 創建 OpenWrt 包結構 ==='
            # 創建 OpenWrt 包結構
            mkdir -p package/trafficmon/files
            cp /tmp/src/target/x86_64-unknown-linux-musl/release/trafficmon package/trafficmon/files/
            chmod +x package/trafficmon/files/trafficmon
            
            # 創建 Makefile
            cat > package/trafficmon/Makefile << 'EOFMAKEFILE'
            include \\\$(TOPDIR)/rules.mk
            
            PKG_NAME:=trafficmon
            PKG_VERSION:=1.0.0
            PKG_RELEASE:=1
            
            PKG_LICENSE:=MIT
            PKG_MAINTAINER:=Steven Ke <stevenke1981@gmail.com>
            
            include \\\$(INCLUDE_DIR)/package.mk
            
            define Package/trafficmon
              SECTION:=net
              CATEGORY:=Network
              TITLE:=Network traffic monitor using nftables
              DEPENDS:=+nftables +kmod-nft-core
              URL:=https://github.com/stevenke1981/trafficmon-rust
            endef
            
            define Package/trafficmon/description
              Monitor network traffic on specified interfaces using nftables counters.
              Outputs statistics to JSON format for easy integration.
            endef
            
            define Package/trafficmon/conffiles
            /etc/config/trafficmon
            endef
            
            define Build/Prepare
            	mkdir -p \\\$(PKG_BUILD_DIR)
            endef
            
            define Build/Compile
            	# Binary already compiled by Rust
            endef
            
            define Package/trafficmon/install
            	\\\$(INSTALL_DIR) \\\$(1)/usr/bin
            	\\\$(INSTALL_BIN) ./files/trafficmon \\\$(1)/usr/bin/
            	
            	\\\$(INSTALL_DIR) \\\$(1)/etc/init.d
            	\\\$(INSTALL_BIN) ./files/trafficmon.init \\\$(1)/etc/init.d/trafficmon
            	
            	\\\$(INSTALL_DIR) \\\$(1)/etc/config
            	\\\$(INSTALL_CONF) ./files/trafficmon.config \\\$(1)/etc/config/trafficmon
            endef
            
            \\\$(eval \\\$(call BuildPackage,trafficmon))
            EOFMAKEFILE
            
            # 創建 init 腳本
            cat > package/trafficmon/files/trafficmon.init << 'EOFINIT'
            #!/bin/sh /etc/rc.common
            START=99
            STOP=10
            USE_PROCD=1
            PROG=/usr/bin/trafficmon
            
            start_service() {
                local enabled interfaces interval output_path
                config_load 'trafficmon'
                config_get_bool enabled 'config' 'enabled' 0
                config_get interfaces 'config' 'interfaces' 'eth1 wan'
                config_get interval 'config' 'interval' '5'
                config_get output_path 'config' 'output_path' '/var/run/trafficmon.json'
                
                [ \\\"\\\$enabled\\\" -eq 0 ] && return 1
                
                procd_open_instance
                procd_set_param command \\\$PROG
                procd_set_param env TRAFFICMON_INTERFACES=\\\"\\\$interfaces\\\"
                procd_set_param env TRAFFICMON_INTERVAL=\\\"\\\$interval\\\"
                procd_set_param env TRAFFICMON_OUTPUT=\\\"\\\$output_path\\\"
                procd_set_param respawn 3600 5 5
                procd_set_param stdout 1
                procd_set_param stderr 1
                procd_close_instance
            }
            
            stop_service() {
                logger -t trafficmon \\\"Stopping trafficmon\\\"
            }
            
            service_triggers() {
                procd_add_reload_trigger \\\"trafficmon\\\"
            }
            
            reload_service() {
                stop
                start
            }
            EOFINIT
            
            # 創建 config 檔案
            cat > package/trafficmon/files/trafficmon.config << 'EOFCONFIG'
            config trafficmon 'config'
            	option enabled '1'
            	option interfaces 'eth1 wan'
            	option interval '5'
            	option output_path '/var/run/trafficmon.json'
            EOFCONFIG
            
            chmod +x package/trafficmon/files/trafficmon.init
            
            echo '=== 檢查包結構 ==='
            ls -la package/trafficmon/
            ls -la package/trafficmon/files/
            
            echo '=== 編譯 OpenWrt 包 ==='
            # 編譯 OpenWrt 包
            make package/trafficmon/compile V=s
            
            echo '=== 創建包索引 ==='
            make package/index
            
            echo '=== 查找生成的 IPK 檔案 ==='
            find . -name \"*.ipk\" -type f | head -10
            find bin -name \"*trafficmon*\" -type f | head -10
            
            # 複製生成的 IPK 檔案到主機
            mkdir -p /build/ipk-x86_64
            find bin -name \"*trafficmon*.ipk\" -exec cp {} /build/ipk-x86_64/ \\; || echo '沒有找到 IPK 檔案'
            
            echo '=== 檢查輸出的 IPK 檔案 ==='
            ls -la /build/ipk-x86_64/ || echo 'ipk-x86_64 目錄不存在'
          "

    - name: Check for IPK files
      run: |
        echo "=== 檢查生成的 IPK 檔案 ==="
        if [ -d "ipk-x86_64" ] && [ \"$(ls -A ipk-x86_64 2>/dev/null)\" ]; then
          echo "找到 IPK 檔案:"
          ls -la ipk-x86_64/
        else
          echo "沒有找到 IPK 檔案"
          # 檢查是否有其他輸出
          echo "=== 檢查工作目錄 ==="
          find . -name "*.ipk" -type f | head -10
        fi

    - name: Upload IPK package
      if: success() && hashFiles('ipk-x86_64/*.ipk')
      uses: actions/upload-artifact@v4
      with:
        name: trafficmon-x86_64-ipk
        path: ipk-x86_64/*.ipk

  build-aarch64:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    name: Build for aarch64_cortex-a53

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Find available OpenWrt images
      run: |
        echo "=== 查找可用的 OpenWrt SDK 鏡像 ==="
        # 嘗試查找可用的 aarch64 鏡像
        docker pull openwrt/sdk:x86_64-24.10.0 > /dev/null 2>&1 && echo "✓ x86_64-24.10.0 可用"
        
        # 嘗試其他可能的鏡像名稱
        for image in \
          \"openwrt/sdk:aarch64_cortex-a53-24.10.0\" \
          \"openwrt/sdk:armsr-armv8-24.10.0\" \
          \"openwrt/sdk:rockchip-armv8-24.10.0\" \
          \"openwrt/sdk:mediatek-mt7622-24.10.0\" \
          \"openwrt/sdk:armvirt-24.10.0\"; do
          if docker pull \$image > /dev/null 2>&1; then
            echo \"✓ \$image 可用\"
            echo \"IMAGE_NAME=\$image\" >> \$GITHUB_ENV
            break
          else
            echo \"✗ \$image 不可用\"
          fi
        done
        
        if [ -z \"\$IMAGE_NAME\" ]; then
          echo \"沒有找到可用的 aarch64 鏡像，使用 x86_64 交叉編譯\"
          echo \"IMAGE_NAME=openwrt/sdk:x86_64-24.10.0\" >> \$GITHUB_ENV
          echo \"CROSS_COMPILE=true\" >> \$GITHUB_ENV
        fi

    - name: Build using OpenWrt SDK Docker
      run: |
        echo \"使用鏡像: $IMAGE_NAME\"
        
        if [ \"$CROSS_COMPILE\" = \"true\" ]; then
          echo \"使用 x86_64 SDK 進行交叉編譯\"
          # 使用 x86_64 SDK 進行交叉編譯
          docker run --rm -v \"$(pwd):/build\" -w /build \
            --user root openwrt/sdk:x86_64-24.10.0 \
            /bin/bash -c "
              set -e
              set -x
              
              echo '=== 設置交叉編譯環境 ==='
              # 安裝交叉編譯工具鏈
              apt-get update
              apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
              
              # 在 /tmp 中編譯
              cd /tmp
              cp -r /build/. /tmp/src
              cd /tmp/src
              
              # 安裝 Rust
              export CARGO_HOME=/tmp/cargo
              export RUSTUP_HOME=/tmp/rustup
              curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable --no-modify-path
              export PATH=\$PATH:/tmp/cargo/bin
              
              # 添加 aarch64 musl 目標
              rustup target add aarch64-unknown-linux-musl
              
              # 設置交叉編譯器
              export CC_aarch64_unknown_linux_musl=aarch64-linux-gnu-gcc
              export AR_aarch64_unknown_linux_musl=aarch64-linux-gnu-ar
              
              echo '=== 交叉編譯 Rust 二進位檔案 ==='
              cargo build --release --target aarch64-unknown-linux-musl --jobs \$(nproc)
              
              # 回到 SDK 目錄並創建包
              cd /build
              mkdir -p package/trafficmon/files
              cp /tmp/src/target/aarch64-unknown-linux-musl/release/trafficmon package/trafficmon/files/
              chmod +x package/trafficmon/files/trafficmon
              
              # 其餘步驟與 x86_64 相同...
              # [這裡省略重複的 Makefile 和配置檔案創建代碼]
              
              # 編譯包
              make package/trafficmon/compile V=s
              make package/index
              
              # 複製 IPK 檔案
              mkdir -p /build/ipk-aarch64
              find bin -name \\\"*trafficmon*.ipk\\\" -exec cp {} /build/ipk-aarch64/ \\; || echo '沒有找到 IPK 檔案'
            "
        else
          echo \"使用原生 aarch64 SDK 編譯\"
          # 使用找到的 aarch64 鏡像
          docker run --rm -v \"$(pwd):/build\" -w /build \
            --user root \"$IMAGE_NAME\" \
            /bin/bash -c "
              # [這裡使用與 x86_64 相同的編譯步驟]
              echo '使用原生 aarch64 SDK 編譯...'
              # ... 編譯步驟 ...
            "
        fi

    - name: Upload IPK package
      if: success() && hashFiles('ipk-aarch64/*.ipk')
      uses: actions/upload-artifact@v4
      with:
        name: trafficmon-aarch64-ipk
        path: ipk-aarch64/*.ipk

  create-release:
    needs: [build-x86_64, build-aarch64]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    timeout-minutes: 5
    
    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v4
      
    - name: Create release bundle
      run: |
        mkdir -p release
        # 合併所有 IPK 檔案
        find . -name "*.ipk" -exec cp {} release/ 2>/dev/null \; || true
        echo "Release contents:"
        ls -la release/ || echo "No release files found"